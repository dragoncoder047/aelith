dialog:
  firefoxDontWorkWithGamepads: >-
    Parece que estas usando Firefox. Desafortunadamente, La implementacion e
    Firefox de la API para mandos en web apesta tanto que es inutilizable,
    puedes continuar usando tu mouse y teclado.


    Si realmente quieres usar un mando, por favor usa un navegador distinto,
    como Chrome$fn.switch(&os~mac:, Opera, o Safari~windows:, Opera, o Microsoft
    Edge~linux: o Opera).
  singleJoyConDontHaveEnoughButtons: >-
    Parece que has conectado un solo mando Joy-Con, el cual no tiene suficientes
    botones para jugar este juego. Puedes intentar conectando el otro Joy-Con o
    simplemente usar tu mouse y teclado.
  touchNotSupportedYet: >-
    Este juego no tiene soporte para controles con pantalla tactil, por favor
    conecta un mando o mouse y teclado.
lore:
  box:
    header: Manejo de memoria
    section: "1"
    secName: MEM
    body: >+
      [b]NOMBRE

      &tabvar[/b], [b]const[/b], [b]let[/b] - asigna nueva memoria para
      permitirle al programa ejecutarse


      [b]DESCRIPCION

      &tabvar[/b], [b]const[/b], y [b]let[/b] asignan un nuevo pedazo de
      memoria. No está atado a ningún programa en particular, puede ser
      insertado en cualquier programa tirándolo, e incluso puede ser insertado
      en un proceso actual.

  continuation:
    throw:
      header: Herramientas de depuración
      section: "4"
      secName: THROW
      body: >-
        NOMBRE

        &tab[throw]throw[/throw] - regresa a una ubicación previa en el programa


        SINOPSIS

        &tab[b]throw[/b] \[[b]--capture[/b] | [b]--restore[/b]]


        DESCRIPCION

        &tab[b]throw[/b] es una herramienta para regresar a una posición previa
        en el flujo de trabajo para depurar, sin modificar el estado actual del
        trabajo.


        NOTAS

        &Este [b]throw[/b] está especialmente diseñado para ser usado por la
        herramienta [b]agdb[/b] (la cual actualmente esta ejecutando:
        [b]true[/b]) para poder depurar interactivamente situaciones
        excepcionales.


        ADVERTENCIAS

        &tab[b]throw[/b] guarda el estado del sistema en un nombre de archivo
        predefinido. Debido a esto, solo es posible capturar el estado del
        sistema una vez usando [b]throw[/b]. Debe restaurarse primero antes de
        guardar otra captura.


        HISTORIA

        &tab[b]throw[/b] fue originalmente escrito como una forma para que un
        programa le indique al depurador que algo salió mal y "lance" el control
        de vuelta al operador humano. Exactamente qué lenguaje de programación
        lo implementó primero, nadie lo sabe.
    setjmp:
      header: Herramientas de depuración
      section: "4"
      secName: SETJMP
      body: >-
        NOMBRE

        &tab[setjmp]setjmp[/setjmp] - salir de funciones anidadas profundamente


        SINOPSIS

        &tab[b]setjmp[/b] \[[b]--capture[/b] | [b]--restore[/b]]


        DESCRIPCION

        &tab[b]setjmp[/b] es una herramienta que permite que el programa salga
        rápidamente de una situación excepcional mediante continuaciones. Cuando
        se invoca con [setjmp]longjmp[/setjmp], salta de vuelta al lugar desde
        donde fue capturado, sin importar cuántos stack frames deba atravesar, y
        luego restaura el valor de las variables locales.


        CUIDADOS

        &tab[b]setjmp[/b] solo puede deshacer el stack de llamadas, por lo que
        intentar capturar una segunda continuation mientras una aún está activa
        es un comportamiento indefinido. Para evitar esto, cuando
        [setjmp]setjmp[/setjmp] detecta que ya se ha capturado una continuation,
        se desactiva hasta que la existente se invoque.


        &tabAdemás, si no se puede encontrar una variable local cuando se llama
        a [setjmp]longjmp[/setjmp], [setjmp]setjmp[/setjmp] intentará recrearla.
        Esta es una adición relativamente nueva y no ha sido depurada
        completamente, por lo que usar [setjmp]setjmp[/setjmp] de esta manera
        puede causar fallos adicionales.


        HISTORIA

        &tab[b]setjmp[/b] fue introducido por el estándar [b]C89[/b]. Aunque
        ningún otro lenguaje de programación implementa [b]setjmp[/b] con el
        mismo nombre, muchos hacen uso de setjmp internamente en sus
        implementaciones en C para construir otras estructuras de control
        exóticas.
    yield:
      header: Herramientas de depuración
      section: "4"
      secName: YIELD
      body: >-
        NOMBRE

        &tab[yield]yield[/yield] - cambiar entre dos ubicaciones en un programa


        SINOPSIS

        &tab[b]yield[/b] [b]--to[/b]=[b]<continuation>[/b]


        DESCRIPCION

        &tab[b]yield[/b] es un mecanismo que permite que el programa se detenga,
        cambie a otra tarea, y luego retome la tarea original. Esto es útil
        cuando dos operaciones deben hacerse en paralelo, pero están muy
        separadas.


        HISTORIA

        &tab[b]yield[/b] fue introducido en el contexto de co-rutinas y
        generadores. Permite que una función retorne un valor y luego continúe
        desde donde se quedó. Este concepto es ampliamente utilizado en
        lenguajes como Python y JavaScript para manejar programación asíncrona y
        multi-tarea cooperativa.
    async:
      header: Herramientas de depuración
      section: "4"
      secName: ASYNC
      body: >-
        NOMBRE

        &tab[async]async[/async], [async]resolve[/async] - posponer la captura
        de una continuación


        SINOPSIS

        &tab[b]async[/b] \[comando]

        &tab[b]resolve[/b] <promesa>


        DESCRIPCION

        &tab[b]async[/b] pone en fila un comando en segundo plano, pero no lo
        ejecuta de inmediato. En su lugar, devuelve una promesa que puede usarse
        para iniciar el comando más tarde usando [b]resolve[/b]. Esto es útil
        cuando se desea posponer la ejecución de un comando. En lugar de
        comenzar el comando en el contexto donde fue añadido a la fila, el
        comando comienza desde donde la promise fue resuelta, por lo que el
        contexto puede ser diferente.


        HISTORIA

        &tab[b]async[/b] y [b]await[/b] fueron introducidos para simplificar la
        programación asíncrona. Permiten a los desarrolladores escribir código
        asíncrono que parece síncrono, lo que facilita su lectura y
        mantenimiento. Este concepto ahora es una característica estándar en
        muchos lenguajes modernos, incluyendo JavaScript y Python.
    switch:
      header: Herramientas de depuración
      section: "4"
      secName: SWITCH
      body: >-
        NOMBRE

        &tab[switch]switch[/switch] - copiar el estado anterior al punto actual
        del flujo del programa


        SINOPSIS

        &tab[b]switch[/b] [b]--which[/b]=[b]<continuation>[/b]


        DESCRIPCION

        &tab[b]switch[/b] es una herramienta que permite al programa forzar el
        estado del programa en un punto anterior del flujo a ser reflejado en el
        punto actual. Esto es útil cuando el depurador quiere ver qué habría
        hecho el programa si retornara a una función que no fue llamada por él.


        &tab[b]switch[/b] es una herramienta poderosa, pero también peligrosa.
        Puede causar que el programa entre en un bucle infinito o que se
        bloquee. Úsala con precaución.


        CUIDADOS

        &tabEsta implementación de [b]switch[/b] opera con un búfer de tamaño
        fijo. Los datos que ocupan más de dos stack frames no serán copiados.


        HISTORIA

        &tab[b]switch[/b] es una construcción de bajo nivel que en su forma
        original simplemente calculaba un valor y luego usaba una tabla de
        búsqueda para determinar a dónde ir. En la informática moderna, "switch"
        también se usa en el contexto de "cambio de contexto", donde el sistema
        operativo reemplaza la pila de llamadas de un proceso con la de otro,
        haciendo que el primero se suspenda y el segundo se reanude.
    callcc:
      header: Herramientas de depuración
      section: "4"
      secName: CALL/CC
      body: >-
        NOMBRE

        &tab[callcc]call/cc[/callcc] - depurar el depurador


        SINOPSIS

        &tab[b]call/cc[/b] \[[b]--force-superimpose[/b]]
        \[[b]--extent[/b]=[b]NFRAMES[/b]] \[[b]--oneshot[/b]]
        \[[b]--stack-only[/b]] \[[b]--defer[/b]] \[[b]--fuzz[/b]]
        \[[b]--as-coroutine[/b]]


        DESCRIPCION

        &tab[b]call/cc[/b] es una herramienta que permite al programa
        inspeccionar y manipular su propio estado. Captura el estado actual del
        programa y luego lo guarda en una variable dentro del mismo programa.


        &tabOpciones:


        &tab[b]--force-superimpose[/b]

        &tab&tabLa continuación reemplazará el estado en donde se invoca en
        lugar de regresar a donde fue capturada. Ver [switch]switch(4)[/switch]
        para más detalles.


        &tab[b]--extent[/b]

        &tab&tabCuántos stack frames capturar.


        &tab[b]--oneshot[/b]

        &tab&tabLimpia y elimina automáticamente la continuación luego de que
        sea invocada.


        &tab[b]--stack-only[/b]

        &tab&tabCaptura solo el stack, ignora el heap. Útil si deseas probar un
        flujo de control modificado sin alterar los datos sobre los que opera.


        &tab[b]--defer[/b]

        &tab&tabPospone la captura usando [async]async(4)[/async]. Esta opción
        rara vez es útil sin [b]--stack-only[/b], pero se mantiene como opción
        separada por razones de implementación.


        &tab[b]--cleanup-subprocesses[/b]

        &tab&tabCuando está habilitada, graba los subprocesos activos al
        capturar la continuación. Luego, al invocarla, cualquier otro subproceso
        que se haya iniciado en ese lapso será detenido con una señal
        [b]SIGINT[/b].


        &tab[b]--fuzz[/b]

        &tab&tab alterna los estados de las variables capturadas para probar el
        programa con datos corruptos.


        &tab[b]--as-coroutine[/b]

        &tab&tabCaptura una continuación en formato de una co-rutina, para que
        pueda ser intercambiada usando [yield]yield(4)[/yield].


        HISTORIA

        &tab[b]call/cc[/b], también conocido como
        [b]call-with-current-continuation[/b], es una [rainbow]característica
        única[/rainbow] de algunos lenguajes de programación. Permite capturar
        la continuación actual (lo que queda del programa después) y volver a
        ella más tarde, en cualquier momento, por cualquier razón, un número
        ilimitado de veces — incluso después de que el flujo del programa haya
        regresado previamente desde esa misma continuación.


        &tabCombinado con condicionales, call/cc puede usarse para implementar
        cualquier estructura de control, incluyendo bucles, excepciones,
        generadores, código asíncrono y multi-tarea cooperativa. Debido a su
        alcance infinito, es fácil escribir código con call/cc que es casi
        imposible de entender, y las implementaciones subyacentes suelen tener
        trampas ocultas que pueden causar fallos cuando call/cc se usa de formas
        inusuales.
    assert:
      header: Herramientas de depuración
      section: "4"
      secName: ASSERT
      body: >-
        NOMBRE

        &tab[assert]assert[/assert] - restablecer el sistema a un estado
        conocido y seguro


        SINOPSIS

        &tab[b]assert[/b] [b]--checkpoint[/b]=[b]<continuation>[/b]


        DESCRIPCION

        &tab[b]assert[/b] es una herramienta que permite al depurador
        restablecer todo el sistema a un estado conocido y seguro. Esto es útil
        cuando el programa ha entrado en un estado no responsivo o se ha
        bloqueado.


        &tabSin argumentos, [b]assert[/b] guarda el estado actual del sistema
        como una continuación. La opción [b]--checkpoint[/b], cuando se
        proporciona, restaurará el sistema al estado guardado en la continuación
        especificada.


        HISTORIA

        &tabLas funciones o sentencias [b]assert[/b] se han utilizado en
        lenguajes como C y Python para detectar y diagnosticar errores durante
        el desarrollo. Verifican que ciertas condiciones se cumplan durante la
        ejecución del programa y, si una afirmación falla, indica un error que
        debe corregirse, generalmente causando que el programa se cierre
        instantáneamente. Los sistemas de tipos como TypeScript pueden
        aprovechar las afirmaciones para inferir condiciones que serían
        imposibles de deducir de otra manera.
ctlHint:
  move: "&control.move mover"
  sprint: "&control.sprint correr"
  jump: "&control.jump saltar"
  aim: "&control.aim apuntar"
  throw: "&control.throw tirar"
  look: "&control.look mirar"
  switchItem: "&control.inventory.scroll cambiar de item"
  item:
    trap:
      default: "&control.action1 captura una continuacion"
      async: "&control.action1 captura una promesa"
      blocked.async: Usa la promesa para invocar remotamente
      selectObjects: "&control.action2 select/deselect"
      editFlags: "&control.action3 edita los parametros de captura"
      boostModeToggle: "&control.action4 vuela hacia arriba"
      grab: "&control.target1 agarrarlo"
      stopEdit: "&control.pMenu.back terminar"
    continuation:
      invoke.default: "&control.action1 invoca una continuacio"
      invoke.checkpoint: "&control.action1 invoca un checkpoint"
      grab: "&control.target1 agarrarlo"
    promise:
      capture: "&control.action1 captura una continuacion desde ahi"
      motion: "&control.move mover trampa"
      grab: "&control.target1 agarrarlo"
  pause:
    open: "&control.pause pausar"
    switch: "&control.pMenu.switch cambiar"
    select: "&control.pMenu.select seleccionar"
    back: "&control.pMenu.back back"
    unpause: "&control.pMenu.exit renaudar"
    editSubmit: "&c.keyboard.pMenu.editSubmit subir"
    editCancel: "&c.keyboard.pMenu.editCancel cancelar"
  viewInfo: "&control.info inspeccionar"
  dialog:
    scroll: "&control.dialog.scroll ver mas"
    exit: "&control.dialog.exit cerrar"
    msg.exit: '&important.exitControl cerrar'
continuation.edit:
  flags: Elegir parametros
  pName: Cambiar el nombre de la promesa
  cName: Cambiar el nombre de la continuacion
  invalidName: Nombre invalido
antivirus:
  allClear: El sistema esta limpio
  detected: ¡Codigo malicioso encontrado!
pause:
  paused: Juego pausado
  controllerType: Tipo de control
  ngConnect: Conectarse a Newgrounds.com
  setLanguage: Lenguaje
  automaticLang: Autodectar lenguaje
  preferences: Opciones
  controllerRumble: Habilitar vibracion del mando
  showSpeedrunTimer: Mostrar temporizador
  showControlHints: Mostrar pistas sobre controles
  playBgMusic: Musica de fondo
  playSfx: Efectos de sonido
  cutsceneOnlyFirstTime: Solo mostrar la transicion la primera vez
  restart: Reiniciar juego
  reallyRestart: |-
    Estas seguro de que quieres reiniciar?
    ¡Todo el progreso se perdera!
  stats:
    heading: Estadisticas
    none: "Nada significante, aun..."
    continuations_invoked: continuations invocadas
    lightbulbs_illuminated: bombillas prendidas
    bugs_stomped: bugs aplastados
    levers_switched: palancas jaladas
    boxes_cloned: memoria localizada
    deaths: muertes
dead:
  complete: Debugging complete.
  failed: failed to eliminate all bugs!
  resume: Resume from a previous checkpoint
  checkpoint: Checkpoint
  fromBeginning: from the beginning
press: presionar
notImplemented: "Lo siento, no esta implementado aun"
bsod.sadfaceMsg: "El juego tuvo un problema que no pudo manejar, tienes que reiniciarlo."
bsod.searchOnlineHint: "Puedes buscar el error online:"
