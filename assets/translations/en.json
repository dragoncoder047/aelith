{
    "startup": {
        "password": "Password for &user: ",
        "loggedInOK": "Logged in!",
        "pressToBegin": "Press ENTER to start...",
        "connecting": "connecting... ",
        "connected": "connected!",
        "ai.prompt": "ask AI",
        "findAnswer": "find the answer",
        "startingDebugger": "Starting debugger...",
        "segfault": "segmentation fault",
        "running": "Assistant is running",
        "disconnected": "Fatal error: disconnected!"
    },
    "lore": {
        "box": {
            "header": "Memory Management",
            "section": "1",
            "secName": "MEM",
            "body": "[b]NAME\n&tabvar[/b], [b]const[/b], [b]let[/b] - allocate new memory to enable a program to run\n\n[b]DESCRIPTION\n&tabvar[/b], [b]const[/b], and [b]let[/b] allocate a chunk of memory. It is not tied to any particular program. It may be inserted into any program by throwing it in, and can even be inserted into the currently-running process (which appears to be: [b]&startup.cmd[/b]).\n\n"
        },
        "continuation": {
            "throw": {
                "header": "Debugging Tools",
                "section": "4",
                "secName": "THROW",
                "body": "NAME\n&tab[throw]throw[/throw] - return to a previous location in the program\n\nSYNOPSIS\n&tab[b]throw[/b] \\[[b]--capture[/b] | [b]--restore[/b]]\n\nDESCRIPTION\n&tab[b]throw[/b] is a tool to instantly return to a previous position in a debugging workflow while modifying nothing about the program's current state.\n\nNOTES\n&tabThis [b]throw[/b] is specially designed to be usable by the [b]agdb[/b] tool (which is currently running: [b]true[/b]) to be able to interactively debug exceptional situations.\n\nCAVEATS\n&tab[b]throw[/b] saves the system state to a hard-coded file name. Because of this it is only possible to capture the system state once using [b]throw[/b]. It must be restored first before another snapshot is saved.\n\nHISTORY\n&tab[b]throw[/b] was originally written as a way for a program to signal to the debugger that something has gone wrong and \"throw\" control back to the human operator. Exactly which programming language implemented it first, no one knows."
            },
            "setjmp": {
                "header": "Debugging Tools",
                "section": "4",
                "secName": "SETJMP",
                "body": "NAME\n&tab[setjmp]setjmp[/setjmp] - break out of deeply nested functions\n\nSYNOPSIS\n&tab[b]setjmp[/b] \\[[b]--capture[/b] | [b]--restore[/b]]\n\nDESCRIPTION\n&tab[b]setjmp[/b] is a tool that allows the program to exit quickly from an exceptional situation via continuations. When invoked via [setjmp]longjmp[/setjmp], it jumps back to the place it was captured from -- no matter how many stack frames it must jump through -- and then restores the value of local variables.\n\nCAVEATS\n&tab[b]setjmp[/b] can only unwind the call stack, so trying to capture a second continuation while one is still active is undefined behavior. To prevent this from happening, when [setjmp]setjmp[/setjmp] detects that a continuation has already been captured, it turns off until the existing continuation is invoked.\n\n&tabAdditionally, if a local variable can not be found when the [setjmp]longjmp[/setjmp] is called, [setjmp]setjmp[/setjmp] will attempt to re-create it. This is a relatively new addition, and has not been debugged thouroughly, so using [setjmp]setjmp[/setjmp] in this manner may cause additional glitches.\n\nHISTORY\n&tab[b]setjmp[/b] was introduced by the [b]C89[/b] standard. While no other programming language implements [b]setjmp[/b] under the same name, other programming languages do setjmp'ing in their C implementations to implement other exotic control flow structures."
            },
            "yield": {
                "header": "Debugging Tools",
                "section": "4",
                "secName": "YIELD",
                "body": "NAME\n&tab[yield]yield[/yield] - switch back and forth between two locations in a program\n\nSYNOPSIS\n&tab[b]yield[/b] [b]--to[/b]=[b]<continuation>[/b]\n\nDESCRIPTION\n&tab[b]yield[/b] is a mechanism that allows the program to stop what it is doing, switch to another task, and then return to the original task. This is useful when two operations must be done in parallel, but they are far apart.\n\nHISTORY\n&tab[b]yield[/b] was introduced in the context of coroutines and generators. It allows a function to return a value and later resume from where it left off. This concept is widely used in languages like Python and JavaScript to handle asynchronous programming and cooperative multitasking."
            },
            "async": {
                "header": "Debugging Tools",
                "section": "4",
                "secName": "ASYNC",
                "body": "NAME\n&tab[async]async[/async], [async]resolve[/async] - defer capturing a continuation\n\nSYNOPSIS\n&tab[b]async[/b] \\[command]\n&tab[b]resolve[/b] <promise>\n\nDESCRIPTION\n&tab[b]async[/b] queues a command in the background, but does not execute it immediately. Instead, it returns a promise that can be used to start the command later using [b]resolve[/b]. This is useful when you want to defer the execution of a command until a later time. Instead of starting the command in the context where it was queued at, the command is started from where the promise was resolved, so the context may be different.\n\nHISTORY\n&tab[b]async[/b] and [b]await[/b] were introduced to simplify asynchronous programming. They allow developers to write asynchronous code that looks synchronous, making it easier to read and maintain. This concept is now a standard feature in many modern programming languages, including JavaScript and Python."
            },
            "switch": {
                "header": "Debugging Tools",
                "section": "4",
                "secName": "SWITCH",
                "body": "NAME\n&tab[switch]switch[/switch] - copy previous state to the current point in the program flow\n\nSYNOPSIS\n&tab[b]switch[/b] [b]--which[/b]=[b]<continuation>[/b]\n\nDESCRIPTION\n&tab[b]switch[/b] is a tool that allows the program to force the state of the program at a previous point in the program flow to be mirrored at the current point. This is useful when the debugger wants to see what the program would have done if it returns into a function that it wasn't called by.\n\n&tab[b]switch[/b] is a powerful tool, but it is also dangerous. It can cause the program to enter an infinite loop, or to crash. Use with caution.\n\nCAVEATS\n&tabThis implementation of [b]switch[/b] operates with a fixed size buffer. Data that occupies more than two stack frames will not be copied.\n\nHISTORY\n&tab[b]switch[/b] is a rather low-level construct that in its original form, simply computed a value and then used a lookup table to determine where to go next. In modern computing \"switch\" is also used in the context of \"context switching\" where the operating system replaces one process's callstack with that of another process, causing the first process to suspend and the second to resume."
            },
            "callcc": {
                "header": "Debugging Tools",
                "section": "4",
                "secName": "CALL/CC",
                "body": "NAME\n&tab[callcc]call/cc[/callcc] - debug the debugger\n\nSYNOPSIS\n&tab[b]call/cc[/b] \\[[b]--copy-here[/b]] \\[[b]--extent[/b]=[b]NFRAMES[/b]] \\[[b]--stack-only[/b]] \\[[b]--defer[/b]] \\[[b]--return[/b]]\n\n DESCRIPTION\n&tab[b]call/cc[/b] is a tool that allows the program to inspect and manipulate its own state. It captures the current state of the program and then stuffs it in the variable in the program.\n\n&tabOptions:\n\n&tab[b]--copy-here[/b]\n&tab&tabThe continuation will replace the state of where it is invoked rather than jumping back to where it was captured from. See [switch]switch(4)[/switch] for details.\n\n&tab[b]--extent[/b]\n&tab&tabHow many stack frames to capture.\n\n&tab[b]--stack-only[/b]\n&tab&tabOnly capture the stack, ignore the heap\n\n&tab[b]--defer[/b]\n&tab&tabDefer the capture using [async]async(4)[/async].\n\n&tab[b]--return[/b]\n&tab&tabAutomatically trigger capturing another continuation using the same options, but from where the continuation is invoked.\n\nHISTORY\n&tab[b]call/cc[/b], also known as [b]call-with-current-continuation[/b], is a [rainbow]unique feature[/rainbow] of some programming languages. It allows a program to capture its current continuation (the rest of the program after it) and return to it later, at any time, for any reason, an unlimited number of times - even after program flow has already returned previously from the same continuation.\n\n&tabCombined with a conditional, call/cc can be used to implement any control structure, including loops, exceptions, generators, asynchronous code, and cooperative multitasking. Because of its infinite extent, it is easy to write code using call/cc that is fairly impossible to understand, and the underlying implementations of call/cc often contain hidden gotchas that can cause the program to crash when call/cc is used in weird ways."
            },
            "assert": {
                "header": "Debugging Tools",
                "section": "4",
                "secName": "ASSERT",
                "body": "NAME\n&tab[assert]assert[/assert] - reset the system to a known, safe state\n\nSYNOPSIS\n&tab[b]assert[/b] [b]--checkpoint[/b]=[b]<continuation>[/b]\n\nDESCRIPTION\n&tab[b]assert[/b] is a tool that allows the debugger to reset the entire system to a known, safe state. This is useful when the program has entered an unresponsive state or has crashed.\n\n&tabWith no arguments, [b]assert[/b] saves the current state of the system to a continuation. The [b]--checkpoint[/b] option, when given, will restore the system to the state saved in the specified continuation.\n\nHISTORY\n&tab[b]assert[/b] functions or statements have been used in programming languages like C and Python to catch and diagnose errors during development. They verify that certain conditions hold true during program execution, and if an assertion fails, it indicates a bug that needs to be fixed, and typically causes the program to crash instantly. Type systems like TypeScript can take advantage of assertions to automatically conclude that certain conditions hold true after the assertion, and thus infer things that would otherwise be impossible to determine."
            }
        }
    },
    "ctlHint": {
        "move": "&control.move move",
        "sprint": "&control.sprint sprint",
        "jump": "&control.jump jump",
        "aim": "&control.aim aim",
        "throw": "&control.throw throw",
        "look": "&control.look look",
        "grab": "&control.interact grab",
        "interact": "&control.interact interact",
        "switchItem": "&control.inventory.scroll switch item",
        "pause": {
            "open": "&control.pause pause game",
            "switch": "&control.pMenu.switch switch",
            "select": "&control.pMenu.select select",
            "back": "&control.pMenu.back back",
            "editSubmit": "&c.keyboard.pMenu.editSubmit submit",
            "editCancel": "&c.keyboard.pMenu.editCancel cancel"
        },
        "viewInfo": "&control.info inspect",
        "manpage": {
            "scroll": "&control.manpage.scroll view more",
            "exit": "&control.manpage.exit close"
        },
        "continuation": {
            "default": "&control.invoke capture a continuation",
            "throw": "&control.invoke capture a promise",
            "promise": "&control.invoke capture continuation from there",
            "usePromise": "Use the promise to invoke remotely",
            "modify": "&control.modify change capture radius",
            "invoke": {
                "default": "&control.invoke invoke continuation",
                "assert": "&control.invoke invoke checkpoint"
            }
        }
    },
    "antivirus": {
        "allClear": "System is clean",
        "detected": "Rogue code detected!"
    },
    "pause": {
        "suspended": "suspended",
        "continued": "continued",
        "select": "Controller type",
        "ngConnect": "Connect to Newgrounds.com",
        "setLanguage": "Language",
        "automaticLang": "Autodetect language",
        "preferences": "Options",
        "controllerRumble": "Enable controller rumble",
        "showSpeedrunTimer": "Show speedrun timer",
        "showControlHints": "Show control hints",
        "playBgMusic": "Play background music",
        "playSfx": "Play sound effects",
        "restart": "Restart game",
        "reallyRestart": "Are you sure you want to restart?\n  All progress will be lost!"
    },
    "dead": {
        "complete": "Debugging complete.",
        "failed": "failed to eliminate all bugs!",
        "resume": "Resume from a previous checkpoint",
        "checkpoint": "Checkpoint",
        "fromBeginning": "from the beginning"
    },
    "press": "press",
    "eekBug": "Eek! A bug!",
    "notImplemented": "Not implemented yet, sorry",
    "gameErrored": "The game ran into a problem that it couldn't handle, and now it needs to be restarted.",
    "gameErrorDetails": "You can search for the error online:",
    "wrongWayLeft": "&arrow.left Go that way",
    "firstDoor": "To open the door, you will need to press\nand hold the button...\nif only you could do that...",
    "firstCheckpoint": "&arrow.left Congrats,\n  your first\n  checkpoint!",
    "thisLightbulb": "&arrow.up ...like this\n  lightbulb",
    "button": "Buttons trigger things while they are pressed...",
    "variable": "This is a variable.\nThese will be very useful!",
    "nothingToSee": "Nothing to see over here",
    "firstContinuation": "That [assert]green[/assert] thing you are holding?\nIt's a [bouncy][rainbow]continuation![/rainbow][/bouncy]\nGo on, invoke it!",
    "firstTrap": "With that [throw]blue[/throw] device, you can capture your own continuations!\nDon't be shy -- grab it!",
    "firstChallenge": "There are a lot of race condition bugs... you'll have to use continuations to get around them.",
    "completedFirstChallenge": "That was easy,\nwasn't it?",
    "noMoreHelp": "There are more bugs, but I can't help you with them. Good luck!",
    "fellOut": "Well, now you're in a pickle...\nContinuations are your friend!",
    "slightlyDifferent": "This one behaves slightly differently... probably a good thing!",
    "secret": "[bouncy][rainbow]shh, secret?[/rainbow][/bouncy]",
    "noSecret": "well, you found nothing\n\nmaybe the game will be updated...",
    "powerful": "this one is [bouncy][rainbow]extremely powerful![/rainbow][/bouncy]",
    "congrats": "[bouncy][rainbow]CONGRATULATIONS![/rainbow][/bouncy]\nyou have reached the end of the game so far!!"
}