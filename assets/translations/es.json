{
    "dialog": {
        "firefoxDontWorkWithGamepads": "Parece que estas usando Firefox. Desafortunadamente, La implementacion e Firefox de la API para mandos en web apesta tanto que es inutilizable, puedes continuar usando tu mouse y teclado.\n\nSi realmente quieres usar un mando, por favor usa un navegador distinto, como Chrome$fn.switch(&os~mac:, Opera, o Safari~windows:, Opera, o Microsoft Edge~linux: o Opera).",
        "singleJoyConDontHaveEnoughButtons": "Parece que has conectado un solo mando Joy-Con, el cual no tiene suficientes botones para jugar este juego. Puedes intentar conectando el otro Joy-Con o simplemente usar tu mouse y teclado.",
        "touchNotSupportedYet": "Este juego no tiene soporte para controles con pantalla tactil, por favor conecta un mando o mouse y teclado."
    },
    "lore": {
        "box": {
            "header": "Manejo de memoria",
            "section": "1",
            "secName": "MEM",
            "body": "[b]NOMBRE\n&tabvar[/b], [b]const[/b], [b]let[/b] - asigna nueva memoria para permitirle al programa ejecutarse\n\n[b]DESCRIPCION\n&tabvar[/b], [b]const[/b], y [b]let[/b] asignan un nuevo pedazo de memoria. No está atado a ningún programa en particular, puede ser insertado en cualquier programa tirándolo, e incluso puede ser insertado en un proceso actual (el cual parece ser: [b]&system.command[/b]).\n\n"
          },
          "continuation": {
            "throw": {
              "header": "Herramientas de depuración",
              "section": "4",
              "secName": "THROW",
              "body": "NOMBRE\n&tab[throw]throw[/throw] - regresa a una ubicación previa en el programa\n\nSINOPSIS\n&tab[b]throw[/b] \\[[b]--capture[/b] | [b]--restore[/b]]\n\nDESCRIPCION\n&tab[b]throw[/b] es una herramienta para regresar a una posición previa en el flujo de trabajo para depurar, sin modificar el estado actual del trabajo.\n\nNOTAS\n&Este [b]throw[/b] está especialmente diseñado para ser usado por la herramienta [b]agdb[/b] (la cual actualmente esta ejecutando: [b]true[/b]) para poder depurar interactivamente situaciones excepcionales.\n\nADVERTENCIAS\n&tab[b]throw[/b] guarda el estado del sistema en un nombre de archivo predefinido. Debido a esto, solo es posible capturar el estado del sistema una vez usando [b]throw[/b]. Debe restaurarse primero antes de guardar otra captura.\n\nHISTORIA\n&tab[b]throw[/b] fue originalmente escrito como una forma para que un programa le indique al depurador que algo salió mal y \"lance\" el control de vuelta al operador humano. Exactamente qué lenguaje de programación lo implementó primero, nadie lo sabe."
            },
            "setjmp": {
              "header": "Herramientas de depuración",
              "section": "4",
              "secName": "SETJMP",
              "body": "NOMBRE\n&tab[setjmp]setjmp[/setjmp] - salir de funciones anidadas profundamente\n\nSINOPSIS\n&tab[b]setjmp[/b] \\[[b]--capture[/b] | [b]--restore[/b]]\n\nDESCRIPCION\n&tab[b]setjmp[/b] es una herramienta que permite que el programa salga rápidamente de una situación excepcional mediante continuaciones. Cuando se invoca con [setjmp]longjmp[/setjmp], salta de vuelta al lugar desde donde fue capturado, sin importar cuántos stack frames deba atravesar, y luego restaura el valor de las variables locales.\n\nCUIDADOS\n&tab[b]setjmp[/b] solo puede deshacer el stack de llamadas, por lo que intentar capturar una segunda continuation mientras una aún está activa es un comportamiento indefinido. Para evitar esto, cuando [setjmp]setjmp[/setjmp] detecta que ya se ha capturado una continuation, se desactiva hasta que la existente se invoque.\n\n&tabAdemás, si no se puede encontrar una variable local cuando se llama a [setjmp]longjmp[/setjmp], [setjmp]setjmp[/setjmp] intentará recrearla. Esta es una adición relativamente nueva y no ha sido depurada completamente, por lo que usar [setjmp]setjmp[/setjmp] de esta manera puede causar fallos adicionales.\n\nHISTORIA\n&tab[b]setjmp[/b] fue introducido por el estándar [b]C89[/b]. Aunque ningún otro lenguaje de programación implementa [b]setjmp[/b] con el mismo nombre, muchos hacen uso de setjmp internamente en sus implementaciones en C para construir otras estructuras de control exóticas."
            },
            "yield": {
              "header": "Herramientas de depuración",
              "section": "4",
              "secName": "YIELD",
              "body": "NOMBRE\n&tab[yield]yield[/yield] - cambiar entre dos ubicaciones en un programa\n\nSINOPSIS\n&tab[b]yield[/b] [b]--to[/b]=[b]<continuation>[/b]\n\nDESCRIPCION\n&tab[b]yield[/b] es un mecanismo que permite que el programa se detenga, cambie a otra tarea, y luego retome la tarea original. Esto es útil cuando dos operaciones deben hacerse en paralelo, pero están muy separadas.\n\nHISTORIA\n&tab[b]yield[/b] fue introducido en el contexto de co-rutinas y generadores. Permite que una función retorne un valor y luego continúe desde donde se quedó. Este concepto es ampliamente utilizado en lenguajes como Python y JavaScript para manejar programación asíncrona y multi-tarea cooperativa."
            },
            "async": {
              "header": "Herramientas de depuración",
              "section": "4",
              "secName": "ASYNC",
              "body": "NOMBRE\n&tab[async]async[/async], [async]resolve[/async] - posponer la captura de una continuación\n\nSINOPSIS\n&tab[b]async[/b] \\[comando]\n&tab[b]resolve[/b] <promesa>\n\nDESCRIPCION\n&tab[b]async[/b] pone en fila un comando en segundo plano, pero no lo ejecuta de inmediato. En su lugar, devuelve una promesa que puede usarse para iniciar el comando más tarde usando [b]resolve[/b]. Esto es útil cuando se desea posponer la ejecución de un comando. En lugar de comenzar el comando en el contexto donde fue añadido a la fila, el comando comienza desde donde la promise fue resuelta, por lo que el contexto puede ser diferente.\n\nHISTORIA\n&tab[b]async[/b] y [b]await[/b] fueron introducidos para simplificar la programación asíncrona. Permiten a los desarrolladores escribir código asíncrono que parece síncrono, lo que facilita su lectura y mantenimiento. Este concepto ahora es una característica estándar en muchos lenguajes modernos, incluyendo JavaScript y Python."
            },
            "switch": {
              "header": "Herramientas de depuración",
              "section": "4",
              "secName": "SWITCH",
              "body": "NOMBRE\n&tab[switch]switch[/switch] - copiar el estado anterior al punto actual del flujo del programa\n\nSINOPSIS\n&tab[b]switch[/b] [b]--which[/b]=[b]<continuation>[/b]\n\nDESCRIPCION\n&tab[b]switch[/b] es una herramienta que permite al programa forzar el estado del programa en un punto anterior del flujo a ser reflejado en el punto actual. Esto es útil cuando el depurador quiere ver qué habría hecho el programa si retornara a una función que no fue llamada por él.\n\n&tab[b]switch[/b] es una herramienta poderosa, pero también peligrosa. Puede causar que el programa entre en un bucle infinito o que se bloquee. Úsala con precaución.\n\nCUIDADOS\n&tabEsta implementación de [b]switch[/b] opera con un búfer de tamaño fijo. Los datos que ocupan más de dos stack frames no serán copiados.\n\nHISTORIA\n&tab[b]switch[/b] es una construcción de bajo nivel que en su forma original simplemente calculaba un valor y luego usaba una tabla de búsqueda para determinar a dónde ir. En la informática moderna, \"switch\" también se usa en el contexto de \"cambio de contexto\", donde el sistema operativo reemplaza la pila de llamadas de un proceso con la de otro, haciendo que el primero se suspenda y el segundo se reanude."
            },
            "callcc": {
              "header": "Herramientas de depuración",
              "section": "4",
              "secName": "CALL/CC",
              "body": "NOMBRE\n&tab[callcc]call/cc[/callcc] - depurar el depurador\n\nSINOPSIS\n&tab[b]call/cc[/b] \\[[b]--force-superimpose[/b]] \\[[b]--extent[/b]=[b]NFRAMES[/b]] \\[[b]--oneshot[/b]] \\[[b]--stack-only[/b]] \\[[b]--defer[/b]] \\[[b]--fuzz[/b]] \\[[b]--as-coroutine[/b]]\n\nDESCRIPCION\n&tab[b]call/cc[/b] es una herramienta que permite al programa inspeccionar y manipular su propio estado. Captura el estado actual del programa y luego lo guarda en una variable dentro del mismo programa.\n\n&tabOpciones:\n\n&tab[b]--force-superimpose[/b]\n&tab&tabLa continuación reemplazará el estado en donde se invoca en lugar de regresar a donde fue capturada. Ver [switch]switch(4)[/switch] para más detalles.\n\n&tab[b]--extent[/b]\n&tab&tabCuántos stack frames capturar.\n\n&tab[b]--oneshot[/b]\n&tab&tabLimpia y elimina automáticamente la continuación luego de que sea invocada.\n\n&tab[b]--stack-only[/b]\n&tab&tabCaptura solo el stack, ignora el heap. Útil si deseas probar un flujo de control modificado sin alterar los datos sobre los que opera.\n\n&tab[b]--defer[/b]\n&tab&tabPospone la captura usando [async]async(4)[/async]. Esta opción rara vez es útil sin [b]--stack-only[/b], pero se mantiene como opción separada por razones de implementación.\n\n&tab[b]--cleanup-subprocesses[/b]\n&tab&tabCuando está habilitada, graba los subprocesos activos al capturar la continuación. Luego, al invocarla, cualquier otro subproceso que se haya iniciado en ese lapso será detenido con una señal [b]SIGINT[/b].\n\n&tab[b]--fuzz[/b]\n&tab&tab alterna los estados de las variables capturadas para probar el programa con datos corruptos.\n\n&tab[b]--as-coroutine[/b]\n&tab&tabCaptura una continuación en formato de una co-rutina, para que pueda ser intercambiada usando [yield]yield(4)[/yield].\n\nHISTORIA\n&tab[b]call/cc[/b], también conocido como [b]call-with-current-continuation[/b], es una [rainbow]característica única[/rainbow] de algunos lenguajes de programación. Permite capturar la continuación actual (lo que queda del programa después) y volver a ella más tarde, en cualquier momento, por cualquier razón, un número ilimitado de veces — incluso después de que el flujo del programa haya regresado previamente desde esa misma continuación.\n\n&tabCombinado con condicionales, call/cc puede usarse para implementar cualquier estructura de control, incluyendo bucles, excepciones, generadores, código asíncrono y multi-tarea cooperativa. Debido a su alcance infinito, es fácil escribir código con call/cc que es casi imposible de entender, y las implementaciones subyacentes suelen tener trampas ocultas que pueden causar fallos cuando call/cc se usa de formas inusuales."
            },
            "assert": {
              "header": "Herramientas de depuración",
              "section": "4",
              "secName": "ASSERT",
              "body": "NOMBRE\n&tab[assert]assert[/assert] - restablecer el sistema a un estado conocido y seguro\n\nSINOPSIS\n&tab[b]assert[/b] [b]--checkpoint[/b]=[b]<continuation>[/b]\n\nDESCRIPCION\n&tab[b]assert[/b] es una herramienta que permite al depurador restablecer todo el sistema a un estado conocido y seguro. Esto es útil cuando el programa ha entrado en un estado no responsivo o se ha bloqueado.\n\n&tabSin argumentos, [b]assert[/b] guarda el estado actual del sistema como una continuación. La opción [b]--checkpoint[/b], cuando se proporciona, restaurará el sistema al estado guardado en la continuación especificada.\n\nHISTORIA\n&tabLas funciones o sentencias [b]assert[/b] se han utilizado en lenguajes como C y Python para detectar y diagnosticar errores durante el desarrollo. Verifican que ciertas condiciones se cumplan durante la ejecución del programa y, si una afirmación falla, indica un error que debe corregirse, generalmente causando que el programa se cierre instantáneamente. Los sistemas de tipos como TypeScript pueden aprovechar las afirmaciones para inferir condiciones que serían imposibles de deducir de otra manera."
            }
        }
    },
    "ctlHint": {
        "move": "&control.move mover",
        "sprint": "&control.sprint correr",
        "jump": "&control.jump saltar",
        "aim": "&control.aim apuntar",
        "throw": "&control.throw tirar",
        "look": "&control.look mirar",
        "grab": "&control.interact agarrar",
        "interact": "&control.interact interactuar",
        "switchItem": "&control.inventory.scroll cambiar de item",
        "pause": {
            "open": "&control.pause pausar",
            "switch": "&control.pMenu.switch cambiar",
            "select": "&control.pMenu.select seleccionar",
            "back": "&control.pMenu.back back",
            "unpause": "&control.pMenu.exit renaudar",
            "editSubmit": "&c.keyboard.pMenu.editSubmit subir",
            "editCancel": "&c.keyboard.pMenu.editCancel cancelar"
        },
        "viewInfo": "&control.info inspeccionar",
        "dialog": {
            "scroll": "&control.dialog.scroll ver mas",
            "exit": "&control.dialog.exit cerrar",
            "msg.exit": "\\[esc] cerrar"
        },
        "continuation": {
            "default": "&control.invoke captura una continuacion",
            "throw": "&control.invoke captura una promesa",
            "promise": "&control.invoke captura una continuacion desde ahi",
            "usePromise": "Usa la promesa para invocar remotamente",
            "modify": "&control.modify cambia el radio de captura",
            "edit": "&control.edit edita los parametros de captura",
            "stopEdit": "&control.edit terminar",
            "fly": "&control.flyUp vuela hacia arriba",
            "remoteMove": "&control.flyUp mover trampa",
            "invoke": {
                "default": "&control.invoke invoca una continuacion",
                "assert": "&control.invoke invoca un checkpoint"
            }
        }
    },
    "continuation.edit": {
        "flags": "Elegir parametros",
        "pName": "Cambiar el nombre de la promesa",
        "cName": "Cambiar el nombre de la continuacion",
        "invalidName": "Nombre invalido"
    },
    "antivirus": {
        "allClear": "El sistema esta limpio",
        "detected": "¡Codigo malicioso encontrado!"
    },
    "pause": {
        "paused": "Juego pausado",
        "controllerType": "Tipo de control",
        "ngConnect": "Conectarse a Newgrounds.com",
        "setLanguage": "Lenguaje",
        "automaticLang": "Autodectar lenguaje",
        "preferences": "Opciones",
        "controllerRumble": "Habilitar vibracion del mando",
        "showSpeedrunTimer": "Mostrar temporizador",
        "showControlHints": "Mostrar pistas sobre controles",
        "playBgMusic": "Musica de fondo",
        "playSfx": "Efectos de sonido",
        "cutsceneOnlyFirstTime": "Solo mostrar la transicion la primera vez",
        "restart": "Reiniciar juego",
        "reallyRestart": "Estas seguro de que quieres reiniciar?\n¡Todo el progreso se perdera!",
        "stats": {
            "heading": "Estadisticas",
            "none": "Nada significante, aun...",
            "continuations_invoked": "continuations invocadas",
            "lightbulbs_illuminated": "bombillas prendidas",
            "bugs_stomped": "bugs aplastados",
            "levers_switched": "palancas jaladas",
            "boxes_cloned": "memoria localizada",
            "deaths": "muertes"
        }
    },
    "dead": {
        "complete": "Debugging complete.",
        "failed": "failed to eliminate all bugs!",
        "resume": "Resume from a previous checkpoint",
        "checkpoint": "Checkpoint",
        "fromBeginning": "from the beginning"
    },
    "cutscene": {
        "continued": "continuado",
        "startup": {
            "password": "Contraseña para &user: ",
            "loggedInOK": "Sesion iniciada!",
            "pressToBegin": "Presiona ENTER para empezar...",
            "ai.prompt": "preguntale a la IA",
            "findAnswer": "Crea un juego de plataformas desde cero.",
            "answer": "Es una tarea complicada, pero bueno, la suerte esta echada...",
            "startingDebugger": "Iniciando depurador...",
            "segfault": "segmentation fault"
        },
        "sudo": {
            "password": "Contraseña para &user: ",
            "nomemory": "sin memoria inicializando modo agente"
        },
        "race": {
            "name": "bloqueo mutuo",
            "cantKill": "no puede ser terminado",
            "pid": "pid",
            "mustBeKilledFirst": "debe ser terminado primero"
        },
        "pipefail": {
            "noMoreHelp": "Bueno, ese fue el final de el tutorial... Supongo que deberia decir mas ya que me estas depurando, pero tengo la sensacion angustiante de que voy a crashear de nuevo si hago eso, asi que \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd ",
            "unicodeError": "Error obteniendo la tabla Unicode",
            "gaveUp": "Okay, esta bien... inserte emoji imaginario de shrug..."
        },
        "backup": {
            "success": "Se han respaldado 124875 archivos a [b]&cutscene.backup.location/assert[/b]",
            "explanation": "EL archivo &cutscene.backup.location/assert es una manera de que puedas empezar de nuevo si te equivocas y rompes las cosas. Solamente usalo en el commando de assert y vuelve ¡No lo pierdas!"
        }
    },
    "press": "presionar",
    "notImplemented": "Lo siento, no esta implementado aun",
    "bsod.sadfaceMsg": "El juego tuvo un problema que no pudo manejar, tienes que reiniciarlo.",
    "bsod.searchOnlineHint": "Puedes buscar el error online:",
    "wrongWayRight": "Ve por alla &arrow.right",
    "newToDebugging": "Eres nuevo al proceso de depurar? Esta bien! Dirigete aca y te mostrare el lugar.",
    "firstPortal": "Eso es un symlink. Te llevara a otra parte del sistema de archivos.\n&arrow.right",
    "firstButton": "Los botones causan cosas cuando los presionas\n, como esta bombilla",
    "getMeOneToo": "Mientras estas ahi, guardame\nun poco de memoria tambien -- probablemente por eso\ncrashee...",
    "firstVariable": "Esta es una variable.\n¡Estas serán muy útiles!",
    "firstDoor": "Para abrir la puerta, necesitarás mantener\n presionado ese botón.\nTienes la memoria para eso, ¿verdad?",
    "raceCond": "¿Tal vez por eso crashee...? ¿Una condición causada por multiples hilos? Un poco de jugo de continuation justo ahí, ¡gracias!",
    "firstCheckpoint": "&arrow.left Oops, ese es\n  el archivo de checkpoint\n  ...",
    "firstContinuation": "Esa cosa [assert]verde[/assert] que estás sosteniendo?\nEse es el archivo de respaldo que [assert]assert[/assert] acaba de guardar, ¡que es una [bouncy][rainbow]continuation![/rainbow][/bouncy]\n¡Vamos, invócala!",
    "firstTrap": "Con ese dispositivo [throw]azul[/throw], ¡puedes capturar tus propios archivos de continuación!\nNo seas tímido -- ¡agárralo!",
    "completedFirstChallenge": "Eso fue fácil,\n¿no?",
    "eekBug": "¡Eek! ¡Un bug!",
    "noLadderNoProblem": "¿No tienes una escalera? No hay problema. Tienes las herramientas. Hice un segfault tratando de descubrir cómo usarlas.",
    "slightlyDifferent": "Este se comporta un poco diferente... ¡probablemente sea algo bueno!",
    "fellOut": "Bueno, ahora estás en un lío...\n¡Las continuations son tus amigas!",
    "waterDamage": "Parece que hay un pequeño problema de daño por agua aquí...",
    "noLoneBugs": "Seguramente te suena el hecho de que no hay algo como \"un solo bug\"...",
    "DUMMY": "TONTO"
}