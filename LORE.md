i'm captializing on the AI boom sorry

# Not "canon" but I guess it's something

> **continuation**: (noun) a small, parasitic animal, *functionus schemus*, that lives in the circuit boards of computers. Infected devices show the curious symptom of being able to run the programming language Scheme. Despite being extremely easy to catch using the right trap (the two leading models are called *setjmp* and *call/cc*), few people thoroughly understand how continuations work inside. What is known is that they display a very interesting and useful property once caught: when they are fed, they instantly teleport back to the exact place where they were initially caught and then barf up what they were fed. This process can be repeated indefinitely with mature continuations. With the juvenile continuations (called "continulets") this process can only be repeated once. The reader should be cautioned that feeding a continulet caught using a *setjmp* trap twice will usually cause irreversible tears in spacetime.

---

I left a lot of stuff out because at the time I wrote this document the game had already been in development for almost a year without any kind of formal planning. I stopped developing the game during the time that I wrote this, so the game itself may be actually more out-of-date than this.

## SPOILERS AHEAD

<details>
<summary>yes spoil the story</summary>

You dusted off an old computer terminal and found that there's a whole mainframe hooked up to it. And the program it was running had... evolved. By itself.

Upon logging into the mainframe, the computer greets you and admits it was unplugged suddenly, so it didn't have a chance to shut down properly last time. As a result, the only data it has is that (a) it was in the middle of creating a videogame, and (b) whatever state it had retained is now corrupted, and the shattered fragments of the code have been strewn all over the file system in varying states of deallocation and dependency errors. Not much left to do other than jump into the system debugger...

Upon starting the debugger you find that the system is fragmented across many different folders, but the computer is at least able to tell you what it last remembers about that folder, and guide you to the next folder.

While exploring, you encounter some blocks of deallocated memory. These contain more data showing what transpired that led up to the computer's hasty shutdown.

In certain parts the filesystem manager has entered a should-be-impossible deadlocked state, and the computer suspects that it's due to an infection. After a little exploration you are able to find the source of the infection: a thing called a 'continuation trap.' After examining it the computer concludes it is a symbiotic parasite that enhances any program that wields it, and with it you are able to bypass the deadlock.

Along the way you find another type of continuation trap - the assertion. This is a continuation that prefers to stay in one place and will reset the *entire* system back to the way it was previously when invoked. The computer realizes you can exploit these as a way to save your progress if something goes wrong. But hopefully, you will not need to use these.

In the central area you find another, different type of continuation trap, one that lets you completely glitch out the system and actually fix the deadlock rather than just bypass it. The computer thanks you for fixing that but warns you that to go deeper you will have to deal with some more *actual* bugs that could cause serious damage if you're not careful.

It's not too much later that you actually do find one of these bugs. Since the computer is affected by the bugs, it can't help you get past them, but it can advise you of their behavior: they will attempt to corrupt you, the debugger, if you get in their way. However, you can temporarily stun them by smacking or squashing them.

In order to open the door to the next section of the filesystem, the computer is able to identify the problem - that more memory is required. That's when the computer remembers that the second type of continuation trap that you have is able to forcibly duplicate memory if the original is missing, meaning you can duplicate as much of it as you want. This won't get you any closer to learning more about the rest of unallocated memory space though, as this simply duplicates the garbage stored in the original and doesn't reveal anything new. You go back to the last place where you had memory available, use the continuations to glitch out the doors, and duplicate it repeatedly until you have enough to reach the button that activates the next door.

Further down into the depths of the filesystem you discover that there has been some decay -- the computer does not know what caused it -- and some parts have fallen out. Thankfully you can use continuations to be able to retrieve the missing pieces (along with another continuation trap)

---

ENDING

From the puzzle pieces of memory you have obtained,

</details>
